// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from CDT-commonTypes-v3_2_0.xsd.
 */

#ifndef XSD_V3_2_0_ED_CDT_COMMON_TYPES_HXX
#define XSD_V3_2_0_ED_CDT_COMMON_TYPES_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace onem2m
{
  class ID;
  class nodeID;
  class deviceID;
  class externalID;
  class requestID;
  class roleID;
  class tokenID;
  class nhURI;
  class acpType_base;
  class acpType;
  class labels_base;
  class labels;
  class triggerRecipientID;
  class listOfM2MID_base;
  class listOfM2MID;
  class ipv4;
  class ipv6;
  class poaList_base;
  class poaList;
  class timestamp;
  class absRelTimestamp;
  class typeOfContent;
  class permittedMediaTypes;
  class serializations_base;
  class serializations;
  class contentInfo;
  class scheduleEntry;
  class listOfURIs_base;
  class listOfURIs;
  class listOfDuration;
  class attributeList;
  class resourceTypeList_base;
  class resourceTypeList;
  class sparql;
  class resourceName;
  class attribute;
  class scheduleEntries;
  class setOfAcrs;
  class accessControlRule;
  class responseTypeInfo;
  class contentRef;
  class locationRegion;
  class countryCode;
  class missingData;
  class dataLink;
  class resource;
  class regularResource;
  class announceableResource;
  class announcedResource;
  class announceableSubordinateResource;
  class subordinateResource;
  class announcedSubordinateResource;
  class listOfNCNames_base;
  class listOfNCNames;
  class flexContainerResource;
  class absRelTimestamp_member;
  class absRelTimestamp_member1;
  class accessControlContexts;
  class notificationURI_base;
  class notificationURI;
  class URIReference;
  class countryCode1_base;
  class countryCode1;
  class circRegion_base;
  class circRegion;
  class announcedAttribute_base;
  class announcedAttribute;
  class announcedAttribute1_base;
  class announcedAttribute1;
  class accessControlIpAddresses;
  class ipv4Addresses_base;
  class ipv4Addresses;
  class ipv6Addresses_base;
  class ipv6Addresses;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "CDT-enumerationTypes.hxx"

/**
 * @brief C++ namespace for the %http://www.onem2m.org/xml/protocols
 * schema namespace.
 */
namespace onem2m
{
  /**
   * @brief Class corresponding to the %ID schema type.
   *
   * @nosubgrouping
   */
  class ID: public ::xml_schema::uri
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ID (const ::xml_schema::uri&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ID (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ID (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ID (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ID (const ID& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ID ();
  };

  /**
   * @brief Class corresponding to the %nodeID schema type.
   *
   * @nosubgrouping
   */
  class nodeID: public ::xml_schema::token
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    nodeID ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    nodeID (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    nodeID (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    nodeID (const ::xml_schema::token&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    nodeID (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    nodeID (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    nodeID (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    nodeID (const nodeID& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual nodeID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~nodeID ();
  };

  /**
   * @brief Class corresponding to the %deviceID schema type.
   *
   * @nosubgrouping
   */
  class deviceID: public ::xml_schema::token
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    deviceID ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    deviceID (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    deviceID (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    deviceID (const ::xml_schema::token&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    deviceID (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    deviceID (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    deviceID (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    deviceID (const deviceID& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual deviceID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~deviceID ();
  };

  /**
   * @brief Class corresponding to the %externalID schema type.
   *
   * @nosubgrouping
   */
  class externalID: public ::xml_schema::token
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    externalID ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    externalID (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    externalID (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    externalID (const ::xml_schema::token&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    externalID (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    externalID (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    externalID (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    externalID (const externalID& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual externalID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~externalID ();
  };

  /**
   * @brief Class corresponding to the %requestID schema type.
   *
   * @nosubgrouping
   */
  class requestID: public ::xml_schema::token
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    requestID ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    requestID (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    requestID (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    requestID (const ::xml_schema::token&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    requestID (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    requestID (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    requestID (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    requestID (const requestID& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual requestID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~requestID ();
  };

  /**
   * @brief Class corresponding to the %roleID schema type.
   *
   * @nosubgrouping
   */
  class roleID: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    roleID ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    roleID (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    roleID (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    roleID (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    roleID (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    roleID (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    roleID (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    roleID (const roleID& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual roleID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~roleID ();
  };

  /**
   * @brief Class corresponding to the %tokenID schema type.
   *
   * @nosubgrouping
   */
  class tokenID: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    tokenID ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    tokenID (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    tokenID (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    tokenID (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    tokenID (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    tokenID (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    tokenID (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    tokenID (const tokenID& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual tokenID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~tokenID ();
  };

  /**
   * @brief Class corresponding to the %nhURI schema type.
   *
   * @nosubgrouping
   */
  class nhURI: public ::xml_schema::uri
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    nhURI (const ::xml_schema::uri&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    nhURI (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    nhURI (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    nhURI (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    nhURI (const nhURI& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual nhURI*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~nhURI ();
  };

  /**
   * @brief List class corresponding to the %acpType_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class acpType_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::ID, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    acpType_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    acpType_base (size_type n, const ::onem2m::ID& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    acpType_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::ID, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    acpType_base (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    acpType_base (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    acpType_base (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    acpType_base (const acpType_base& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual acpType_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~acpType_base ();
  };

  /**
   * @brief Class corresponding to the %acpType schema type.
   *
   * @nosubgrouping
   */
  class acpType: public ::onem2m::acpType_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    acpType ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    acpType (const ::onem2m::acpType_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    acpType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    acpType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    acpType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    acpType (const acpType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual acpType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~acpType ();
  };

  /**
   * @brief List class corresponding to the %labels_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class labels_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::token, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    labels_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    labels_base (size_type n, const ::xml_schema::token& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    labels_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::token, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    labels_base (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    labels_base (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    labels_base (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    labels_base (const labels_base& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual labels_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~labels_base ();
  };

  /**
   * @brief Class corresponding to the %labels schema type.
   *
   * @nosubgrouping
   */
  class labels: public ::onem2m::labels_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    labels ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    labels (const ::onem2m::labels_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    labels (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    labels (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    labels (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    labels (const labels& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual labels*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~labels ();
  };

  /**
   * @brief Class corresponding to the %triggerRecipientID schema type.
   *
   * @nosubgrouping
   */
  class triggerRecipientID: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    triggerRecipientID (const ::xml_schema::unsigned_int&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    triggerRecipientID (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    triggerRecipientID (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    triggerRecipientID (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    triggerRecipientID (const triggerRecipientID& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual triggerRecipientID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~triggerRecipientID ();
  };

  /**
   * @brief List class corresponding to the %listOfM2MID_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class listOfM2MID_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::ID, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    listOfM2MID_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    listOfM2MID_base (size_type n, const ::onem2m::ID& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    listOfM2MID_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::ID, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfM2MID_base (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfM2MID_base (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfM2MID_base (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfM2MID_base (const listOfM2MID_base& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfM2MID_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfM2MID_base ();
  };

  /**
   * @brief Class corresponding to the %listOfM2MID schema type.
   *
   * @nosubgrouping
   */
  class listOfM2MID: public ::onem2m::listOfM2MID_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    listOfM2MID ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    listOfM2MID (const ::onem2m::listOfM2MID_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfM2MID (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfM2MID (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfM2MID (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfM2MID (const listOfM2MID& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfM2MID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfM2MID ();
  };

  /**
   * @brief Class corresponding to the %ipv4 schema type.
   *
   * An IP version 4 address, with optional CIDR suffix in the range /0
   * ... /32.
   *
   * @nosubgrouping
   */
  class ipv4: public ::xml_schema::token
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    ipv4 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    ipv4 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    ipv4 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ipv4 (const ::xml_schema::token&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ipv4 (const ipv4& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ipv4*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ipv4 ();
  };

  /**
   * @brief Class corresponding to the %ipv6 schema type.
   *
   * An IP version 6 address, based on RFC 1884, with optional CIDR suffix
   * in the range /0 ... /128.
   *
   * @nosubgrouping
   */
  class ipv6: public ::xml_schema::token
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    ipv6 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    ipv6 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    ipv6 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ipv6 (const ::xml_schema::token&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ipv6 (const ipv6& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ipv6*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ipv6 ();
  };

  /**
   * @brief List class corresponding to the %poaList_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class poaList_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::string, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    poaList_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    poaList_base (size_type n, const ::xml_schema::string& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    poaList_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::string, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    poaList_base (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    poaList_base (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    poaList_base (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    poaList_base (const poaList_base& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual poaList_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~poaList_base ();
  };

  /**
   * @brief Class corresponding to the %poaList schema type.
   *
   * @nosubgrouping
   */
  class poaList: public ::onem2m::poaList_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    poaList ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    poaList (const ::onem2m::poaList_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    poaList (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    poaList (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    poaList (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    poaList (const poaList& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual poaList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~poaList ();
  };

  /**
   * @brief Class corresponding to the %timestamp schema type.
   *
   * @nosubgrouping
   */
  class timestamp: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    timestamp ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    timestamp (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    timestamp (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    timestamp (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    timestamp (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    timestamp (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    timestamp (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    timestamp (const timestamp& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual timestamp*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~timestamp ();
  };

  /**
   * @brief Union class corresponding to the %absRelTimestamp
   * schema type.
   *
   * The mapping represents unions as strings.
   */
  class absRelTimestamp: public ::xml_schema::string
  {
    public:

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    absRelTimestamp (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    absRelTimestamp (const ::std::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    absRelTimestamp (const absRelTimestamp& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual absRelTimestamp*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;
  };

  /**
   * @brief Class corresponding to the %typeOfContent schema type.
   *
   * @nosubgrouping
   */
  class typeOfContent: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    typeOfContent ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    typeOfContent (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    typeOfContent (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    typeOfContent (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    typeOfContent (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    typeOfContent (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    typeOfContent (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    typeOfContent (const typeOfContent& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual typeOfContent*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~typeOfContent ();
  };

  /**
   * @brief Enumeration class corresponding to the %permittedMediaTypes
   * schema type.
   */
  class permittedMediaTypes: public ::onem2m::typeOfContent
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum value
    {
      application_xml,
      application_json,
      application_cbor
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    permittedMediaTypes (value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    permittedMediaTypes (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    permittedMediaTypes (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    permittedMediaTypes (const ::onem2m::typeOfContent& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    permittedMediaTypes (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    permittedMediaTypes (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    permittedMediaTypes (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    permittedMediaTypes (const permittedMediaTypes& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual permittedMediaTypes*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    permittedMediaTypes&
    operator= (value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator value () const
    {
      return _xsd_permittedMediaTypes_convert ();
    }

    //@cond

    protected:
    value
    _xsd_permittedMediaTypes_convert () const;

    public:
    static const char* const _xsd_permittedMediaTypes_literals_[3];
    static const value _xsd_permittedMediaTypes_indexes_[3];

    //@endcond
  };

  /**
   * @brief List class corresponding to the %serializations_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class serializations_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::permittedMediaTypes, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    serializations_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    serializations_base (size_type n, const ::onem2m::permittedMediaTypes& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    serializations_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::permittedMediaTypes, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    serializations_base (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    serializations_base (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    serializations_base (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    serializations_base (const serializations_base& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual serializations_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~serializations_base ();
  };

  /**
   * @brief Class corresponding to the %serializations schema type.
   *
   * @nosubgrouping
   */
  class serializations: public ::onem2m::serializations_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    serializations ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    serializations (const ::onem2m::serializations_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    serializations (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    serializations (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    serializations (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    serializations (const serializations& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual serializations*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~serializations ();
  };

  /**
   * @brief Class corresponding to the %contentInfo schema type.
   *
   * @nosubgrouping
   */
  class contentInfo: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    contentInfo ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    contentInfo (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    contentInfo (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    contentInfo (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    contentInfo (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    contentInfo (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    contentInfo (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    contentInfo (const contentInfo& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual contentInfo*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~contentInfo ();
  };

  /**
   * @brief Class corresponding to the %scheduleEntry schema type.
   *
   * @nosubgrouping
   */
  class scheduleEntry: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    scheduleEntry ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    scheduleEntry (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    scheduleEntry (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    scheduleEntry (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    scheduleEntry (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    scheduleEntry (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    scheduleEntry (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    scheduleEntry (const scheduleEntry& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual scheduleEntry*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~scheduleEntry ();
  };

  /**
   * @brief List class corresponding to the %listOfURIs_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class listOfURIs_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::uri, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    listOfURIs_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    listOfURIs_base (size_type n, const ::xml_schema::uri& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    listOfURIs_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::uri, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfURIs_base (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfURIs_base (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfURIs_base (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfURIs_base (const listOfURIs_base& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfURIs_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfURIs_base ();
  };

  /**
   * @brief Class corresponding to the %listOfURIs schema type.
   *
   * @nosubgrouping
   */
  class listOfURIs: public ::onem2m::listOfURIs_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    listOfURIs ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    listOfURIs (const ::onem2m::listOfURIs_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfURIs (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfURIs (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfURIs (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfURIs (const listOfURIs& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfURIs*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfURIs ();
  };

  /**
   * @brief List class corresponding to the %listOfDuration
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class listOfDuration: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::duration, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    listOfDuration ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    listOfDuration (size_type n, const ::xml_schema::duration& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    listOfDuration (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::duration, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfDuration (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfDuration (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfDuration (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfDuration (const listOfDuration& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfDuration*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfDuration ();
  };

  /**
   * @brief List class corresponding to the %attributeList
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class attributeList: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::ncname, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    attributeList ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    attributeList (size_type n, const ::xml_schema::ncname& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    attributeList (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::ncname, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    attributeList (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    attributeList (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    attributeList (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    attributeList (const attributeList& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual attributeList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~attributeList ();
  };

  /**
   * @brief List class corresponding to the %resourceTypeList_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class resourceTypeList_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::resourceType, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    resourceTypeList_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    resourceTypeList_base (size_type n, const ::onem2m::resourceType& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    resourceTypeList_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::resourceType, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceTypeList_base (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceTypeList_base (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceTypeList_base (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    resourceTypeList_base (const resourceTypeList_base& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual resourceTypeList_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~resourceTypeList_base ();
  };

  /**
   * @brief Class corresponding to the %resourceTypeList schema type.
   *
   * @nosubgrouping
   */
  class resourceTypeList: public ::onem2m::resourceTypeList_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    resourceTypeList ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    resourceTypeList (const ::onem2m::resourceTypeList_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceTypeList (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceTypeList (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceTypeList (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    resourceTypeList (const resourceTypeList& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual resourceTypeList*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~resourceTypeList ();
  };

  /**
   * @brief Class corresponding to the %sparql schema type.
   *
   * @nosubgrouping
   */
  class sparql: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    sparql ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    sparql (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    sparql (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    sparql (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    sparql (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    sparql (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    sparql (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    sparql (const sparql& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual sparql*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~sparql ();
  };

  /**
   * @brief Class corresponding to the %resourceName schema type.
   *
   * @nosubgrouping
   */
  class resourceName: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    resourceName ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    resourceName (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    resourceName (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    resourceName (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceName (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceName (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resourceName (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    resourceName (const resourceName& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual resourceName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~resourceName ();
  };

  /**
   * @brief Class corresponding to the %attribute schema type.
   *
   * @nosubgrouping
   */
  class attribute: public ::xml_schema::type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::ncname name_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    name_type&
    name ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::type value_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const value_type&
    value () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    value_type&
    value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    value (const value_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    value (::std::unique_ptr< value_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    attribute (const name_type&,
               const value_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    attribute (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    attribute (const attribute& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual attribute*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    attribute&
    operator= (const attribute& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~attribute ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< value_type > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %scheduleEntries schema type.
   *
   * @nosubgrouping
   */
  class scheduleEntries: public ::xml_schema::type
  {
    public:
    /**
     * @name scheduleEntry
     *
     * @brief Accessor and modifier functions for the %scheduleEntry
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::scheduleEntry scheduleEntry_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< scheduleEntry_type > scheduleEntry_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef scheduleEntry_sequence::iterator scheduleEntry_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef scheduleEntry_sequence::const_iterator scheduleEntry_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< scheduleEntry_type, char > scheduleEntry_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const scheduleEntry_sequence&
    scheduleEntry () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    scheduleEntry_sequence&
    scheduleEntry ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    scheduleEntry (const scheduleEntry_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    scheduleEntries ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    scheduleEntries (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    scheduleEntries (const scheduleEntries& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual scheduleEntries*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    scheduleEntries&
    operator= (const scheduleEntries& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~scheduleEntries ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    scheduleEntry_sequence scheduleEntry_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %setOfAcrs schema type.
   *
   * @nosubgrouping
   */
  class setOfAcrs: public ::xml_schema::type
  {
    public:
    /**
     * @name accessControlRule
     *
     * @brief Accessor and modifier functions for the %accessControlRule
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::accessControlRule accessControlRule_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< accessControlRule_type > accessControlRule_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef accessControlRule_sequence::iterator accessControlRule_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef accessControlRule_sequence::const_iterator accessControlRule_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlRule_type, char > accessControlRule_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const accessControlRule_sequence&
    accessControlRule () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    accessControlRule_sequence&
    accessControlRule ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    accessControlRule (const accessControlRule_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    setOfAcrs ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    setOfAcrs (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    setOfAcrs (const setOfAcrs& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual setOfAcrs*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    setOfAcrs&
    operator= (const setOfAcrs& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~setOfAcrs ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    accessControlRule_sequence accessControlRule_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %accessControlRule schema type.
   *
   * @nosubgrouping
   */
  class accessControlRule: public ::xml_schema::type
  {
    public:
    /**
     * @name accessControlOriginators
     *
     * @brief Accessor and modifier functions for the %accessControlOriginators
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs accessControlOriginators_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlOriginators_type, char > accessControlOriginators_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const accessControlOriginators_type&
    accessControlOriginators () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    accessControlOriginators_type&
    accessControlOriginators ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlOriginators (const accessControlOriginators_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    accessControlOriginators (::std::unique_ptr< accessControlOriginators_type > p);

    //@}

    /**
     * @name accessControlOperations
     *
     * @brief Accessor and modifier functions for the %accessControlOperations
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::accessControlOperations accessControlOperations_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlOperations_type, char > accessControlOperations_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const accessControlOperations_type&
    accessControlOperations () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    accessControlOperations_type&
    accessControlOperations ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlOperations (const accessControlOperations_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    accessControlOperations (::std::unique_ptr< accessControlOperations_type > p);

    //@}

    /**
     * @name accessControlContexts
     *
     * @brief Accessor and modifier functions for the %accessControlContexts
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::accessControlContexts accessControlContexts_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< accessControlContexts_type > accessControlContexts_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef accessControlContexts_sequence::iterator accessControlContexts_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef accessControlContexts_sequence::const_iterator accessControlContexts_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlContexts_type, char > accessControlContexts_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const accessControlContexts_sequence&
    accessControlContexts () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    accessControlContexts_sequence&
    accessControlContexts ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    accessControlContexts (const accessControlContexts_sequence& s);

    //@}

    /**
     * @name accessControlAuthenticationFlag
     *
     * @brief Accessor and modifier functions for the %accessControlAuthenticationFlag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::boolean accessControlAuthenticationFlag_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< accessControlAuthenticationFlag_type > accessControlAuthenticationFlag_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlAuthenticationFlag_type, char > accessControlAuthenticationFlag_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const accessControlAuthenticationFlag_optional&
    accessControlAuthenticationFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    accessControlAuthenticationFlag_optional&
    accessControlAuthenticationFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlAuthenticationFlag (const accessControlAuthenticationFlag_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    accessControlAuthenticationFlag (const accessControlAuthenticationFlag_optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    accessControlRule (const accessControlOriginators_type&,
                       const accessControlOperations_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    accessControlRule (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    accessControlRule (const accessControlRule& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual accessControlRule*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    accessControlRule&
    operator= (const accessControlRule& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~accessControlRule ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< accessControlOriginators_type > accessControlOriginators_;
    ::xsd::cxx::tree::one< accessControlOperations_type > accessControlOperations_;
    accessControlContexts_sequence accessControlContexts_;
    accessControlAuthenticationFlag_optional accessControlAuthenticationFlag_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %responseTypeInfo schema type.
   *
   * @nosubgrouping
   */
  class responseTypeInfo: public ::xml_schema::type
  {
    public:
    /**
     * @name responseTypeValue
     *
     * @brief Accessor and modifier functions for the %responseTypeValue
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::responseType responseTypeValue_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< responseTypeValue_type, char > responseTypeValue_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const responseTypeValue_type&
    responseTypeValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    responseTypeValue_type&
    responseTypeValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    responseTypeValue (const responseTypeValue_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    responseTypeValue (::std::unique_ptr< responseTypeValue_type > p);

    //@}

    /**
     * @name notificationURI
     *
     * @brief Accessor and modifier functions for the %notificationURI
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::notificationURI notificationURI_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< notificationURI_type > notificationURI_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< notificationURI_type, char > notificationURI_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const notificationURI_optional&
    notificationURI () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    notificationURI_optional&
    notificationURI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    notificationURI (const notificationURI_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    notificationURI (const notificationURI_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    notificationURI (::std::unique_ptr< notificationURI_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    responseTypeInfo (const responseTypeValue_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    responseTypeInfo (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    responseTypeInfo (const responseTypeInfo& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual responseTypeInfo*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    responseTypeInfo&
    operator= (const responseTypeInfo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~responseTypeInfo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< responseTypeValue_type > responseTypeValue_;
    notificationURI_optional notificationURI_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %contentRef schema type.
   *
   * @nosubgrouping
   */
  class contentRef: public ::xml_schema::type
  {
    public:
    /**
     * @name URIReference
     *
     * @brief Accessor and modifier functions for the %URIReference
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::URIReference URIReference_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< URIReference_type > URIReference_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef URIReference_sequence::iterator URIReference_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef URIReference_sequence::const_iterator URIReference_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< URIReference_type, char > URIReference_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const URIReference_sequence&
    URIReference () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    URIReference_sequence&
    URIReference ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    URIReference (const URIReference_sequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    contentRef ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    contentRef (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    contentRef (const contentRef& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual contentRef*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    contentRef&
    operator= (const contentRef& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~contentRef ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    URIReference_sequence URIReference_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %locationRegion schema type.
   *
   * @nosubgrouping
   */
  class locationRegion: public ::xml_schema::type
  {
    public:
    /**
     * @name countryCode
     *
     * @brief Accessor and modifier functions for the %countryCode
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::countryCode1 countryCode_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< countryCode_type > countryCode_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< countryCode_type, char > countryCode_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const countryCode_optional&
    countryCode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    countryCode_optional&
    countryCode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    countryCode (const countryCode_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    countryCode (const countryCode_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    countryCode (::std::unique_ptr< countryCode_type > p);

    //@}

    /**
     * @name circRegion
     *
     * @brief Accessor and modifier functions for the %circRegion
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::circRegion circRegion_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< circRegion_type > circRegion_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< circRegion_type, char > circRegion_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const circRegion_optional&
    circRegion () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    circRegion_optional&
    circRegion ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    circRegion (const circRegion_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    circRegion (const circRegion_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    circRegion (::std::unique_ptr< circRegion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    locationRegion ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    locationRegion (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    locationRegion (const locationRegion& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual locationRegion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    locationRegion&
    operator= (const locationRegion& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~locationRegion ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    countryCode_optional countryCode_;
    circRegion_optional circRegion_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %countryCode schema type.
   *
   * 2-character country code as defined by ISO-3166
   *
   * @nosubgrouping
   */
  class countryCode: public ::xml_schema::string
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    countryCode ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    countryCode (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    countryCode (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    countryCode (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    countryCode (const countryCode& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual countryCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~countryCode ();
  };

  /**
   * @brief Class corresponding to the %missingData schema type.
   *
   * @nosubgrouping
   */
  class missingData: public ::xml_schema::type
  {
    public:
    /**
     * @name number
     *
     * @brief Accessor and modifier functions for the %number
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::non_negative_integer number_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< number_type, char > number_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const number_type&
    number () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    number_type&
    number ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    number (const number_type& x);

    //@}

    /**
     * @name duration
     *
     * @brief Accessor and modifier functions for the %duration
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::duration duration_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const duration_type&
    duration () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    duration_type&
    duration ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    duration (const duration_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    duration (::std::unique_ptr< duration_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    missingData (const number_type&,
                 const duration_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    missingData (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    missingData (const missingData& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual missingData*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    missingData&
    operator= (const missingData& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~missingData ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< number_type > number_;
    ::xsd::cxx::tree::one< duration_type > duration_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %dataLink schema type.
   *
   * @nosubgrouping
   */
  class dataLink: public ::xml_schema::type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::uri name_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    name_type&
    name ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name dataContainerID
     *
     * @brief Accessor and modifier functions for the %dataContainerID
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::ID dataContainerID_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< dataContainerID_type, char > dataContainerID_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const dataContainerID_type&
    dataContainerID () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    dataContainerID_type&
    dataContainerID ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    dataContainerID (const dataContainerID_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    dataContainerID (::std::unique_ptr< dataContainerID_type > p);

    //@}

    /**
     * @name attributeName
     *
     * @brief Accessor and modifier functions for the %attributeName
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::ncname attributeName_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< attributeName_type > attributeName_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< attributeName_type, char > attributeName_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const attributeName_optional&
    attributeName () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    attributeName_optional&
    attributeName ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    attributeName (const attributeName_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    attributeName (const attributeName_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    attributeName (::std::unique_ptr< attributeName_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    dataLink (const name_type&,
              const dataContainerID_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    dataLink (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    dataLink (const dataLink& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual dataLink*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    dataLink&
    operator= (const dataLink& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~dataLink ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< dataContainerID_type > dataContainerID_;
    attributeName_optional attributeName_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %resource schema type.
   *
   * @nosubgrouping
   */
  class resource: public ::xml_schema::type
  {
    public:
    /**
     * @name resourceType
     *
     * @brief Accessor and modifier functions for the %resourceType
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::resourceType resourceType_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< resourceType_type > resourceType_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< resourceType_type, char > resourceType_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const resourceType_optional&
    resourceType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    resourceType_optional&
    resourceType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    resourceType (const resourceType_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    resourceType (const resourceType_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    resourceType (::std::unique_ptr< resourceType_type > p);

    //@}

    /**
     * @name resourceID
     *
     * @brief Accessor and modifier functions for the %resourceID
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::ID resourceID_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< resourceID_type > resourceID_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< resourceID_type, char > resourceID_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const resourceID_optional&
    resourceID () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    resourceID_optional&
    resourceID ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    resourceID (const resourceID_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    resourceID (const resourceID_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    resourceID (::std::unique_ptr< resourceID_type > p);

    //@}

    /**
     * @name parentID
     *
     * @brief Accessor and modifier functions for the %parentID
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::nhURI parentID_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< parentID_type > parentID_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< parentID_type, char > parentID_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const parentID_optional&
    parentID () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    parentID_optional&
    parentID ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    parentID (const parentID_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    parentID (const parentID_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    parentID (::std::unique_ptr< parentID_type > p);

    //@}

    /**
     * @name creationTime
     *
     * @brief Accessor and modifier functions for the %creationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp creationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< creationTime_type > creationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< creationTime_type, char > creationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const creationTime_optional&
    creationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    creationTime_optional&
    creationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    creationTime (const creationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    creationTime (const creationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    creationTime (::std::unique_ptr< creationTime_type > p);

    //@}

    /**
     * @name lastModifiedTime
     *
     * @brief Accessor and modifier functions for the %lastModifiedTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp lastModifiedTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< lastModifiedTime_type > lastModifiedTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< lastModifiedTime_type, char > lastModifiedTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const lastModifiedTime_optional&
    lastModifiedTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    lastModifiedTime_optional&
    lastModifiedTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    lastModifiedTime (const lastModifiedTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    lastModifiedTime (const lastModifiedTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    lastModifiedTime (::std::unique_ptr< lastModifiedTime_type > p);

    //@}

    /**
     * @name labels
     *
     * @brief Accessor and modifier functions for the %labels
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::labels labels_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< labels_type > labels_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< labels_type, char > labels_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const labels_optional&
    labels () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    labels_optional&
    labels ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    labels (const labels_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    labels (const labels_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    labels (::std::unique_ptr< labels_type > p);

    //@}

    /**
     * @name resourceName
     *
     * @brief Accessor and modifier functions for the %resourceName
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::onem2m::resourceName resourceName_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< resourceName_type > resourceName_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< resourceName_type, char > resourceName_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const resourceName_optional&
    resourceName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    resourceName_optional&
    resourceName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    resourceName (const resourceName_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    resourceName (const resourceName_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    resourceName (::std::unique_ptr< resourceName_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    resource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    resource (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    resource (const resource& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual resource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    resource&
    operator= (const resource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~resource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    resourceType_optional resourceType_;
    resourceID_optional resourceID_;
    parentID_optional parentID_;
    creationTime_optional creationTime_;
    lastModifiedTime_optional lastModifiedTime_;
    labels_optional labels_;
    resourceName_optional resourceName_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %regularResource schema type.
   *
   * @nosubgrouping
   */
  class regularResource: public ::onem2m::resource
  {
    public:
    /**
     * @name accessControlPolicyIDs
     *
     * @brief Accessor and modifier functions for the %accessControlPolicyIDs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::acpType accessControlPolicyIDs_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< accessControlPolicyIDs_type > accessControlPolicyIDs_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlPolicyIDs_type, char > accessControlPolicyIDs_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const accessControlPolicyIDs_optional&
    accessControlPolicyIDs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    accessControlPolicyIDs_optional&
    accessControlPolicyIDs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlPolicyIDs (const accessControlPolicyIDs_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    accessControlPolicyIDs (const accessControlPolicyIDs_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    accessControlPolicyIDs (::std::unique_ptr< accessControlPolicyIDs_type > p);

    //@}

    /**
     * @name expirationTime
     *
     * @brief Accessor and modifier functions for the %expirationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp expirationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< expirationTime_type > expirationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expirationTime_type, char > expirationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const expirationTime_optional&
    expirationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    expirationTime_optional&
    expirationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    expirationTime (const expirationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    expirationTime (const expirationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    expirationTime (::std::unique_ptr< expirationTime_type > p);

    //@}

    /**
     * @name dynamicAuthorizationConsultationIDs
     *
     * @brief Accessor and modifier functions for the %dynamicAuthorizationConsultationIDs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs dynamicAuthorizationConsultationIDs_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< dynamicAuthorizationConsultationIDs_type > dynamicAuthorizationConsultationIDs_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< dynamicAuthorizationConsultationIDs_type, char > dynamicAuthorizationConsultationIDs_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const dynamicAuthorizationConsultationIDs_optional&
    dynamicAuthorizationConsultationIDs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    dynamicAuthorizationConsultationIDs_optional&
    dynamicAuthorizationConsultationIDs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    dynamicAuthorizationConsultationIDs (const dynamicAuthorizationConsultationIDs_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    dynamicAuthorizationConsultationIDs (const dynamicAuthorizationConsultationIDs_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    dynamicAuthorizationConsultationIDs (::std::unique_ptr< dynamicAuthorizationConsultationIDs_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    regularResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    regularResource (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    regularResource (const regularResource& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual regularResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    regularResource&
    operator= (const regularResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~regularResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    accessControlPolicyIDs_optional accessControlPolicyIDs_;
    expirationTime_optional expirationTime_;
    dynamicAuthorizationConsultationIDs_optional dynamicAuthorizationConsultationIDs_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %announceableResource schema type.
   *
   * @nosubgrouping
   */
  class announceableResource: public ::onem2m::regularResource
  {
    public:
    /**
     * @name announceTo
     *
     * @brief Accessor and modifier functions for the %announceTo
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs announceTo_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< announceTo_type > announceTo_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< announceTo_type, char > announceTo_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const announceTo_optional&
    announceTo () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    announceTo_optional&
    announceTo ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    announceTo (const announceTo_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    announceTo (const announceTo_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    announceTo (::std::unique_ptr< announceTo_type > p);

    //@}

    /**
     * @name announcedAttribute
     *
     * @brief Accessor and modifier functions for the %announcedAttribute
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::announcedAttribute announcedAttribute_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< announcedAttribute_type > announcedAttribute_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< announcedAttribute_type, char > announcedAttribute_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const announcedAttribute_optional&
    announcedAttribute () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    announcedAttribute_optional&
    announcedAttribute ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    announcedAttribute (const announcedAttribute_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    announcedAttribute (const announcedAttribute_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    announcedAttribute (::std::unique_ptr< announcedAttribute_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    announceableResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announceableResource (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announceableResource (const announceableResource& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announceableResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announceableResource&
    operator= (const announceableResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~announceableResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    announceTo_optional announceTo_;
    announcedAttribute_optional announcedAttribute_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %announcedResource schema type.
   *
   * @nosubgrouping
   */
  class announcedResource: public ::onem2m::resource
  {
    public:
    /**
     * @name accessControlPolicyIDs
     *
     * @brief Accessor and modifier functions for the %accessControlPolicyIDs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::acpType accessControlPolicyIDs_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< accessControlPolicyIDs_type > accessControlPolicyIDs_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlPolicyIDs_type, char > accessControlPolicyIDs_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const accessControlPolicyIDs_optional&
    accessControlPolicyIDs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    accessControlPolicyIDs_optional&
    accessControlPolicyIDs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlPolicyIDs (const accessControlPolicyIDs_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    accessControlPolicyIDs (const accessControlPolicyIDs_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    accessControlPolicyIDs (::std::unique_ptr< accessControlPolicyIDs_type > p);

    //@}

    /**
     * @name expirationTime
     *
     * @brief Accessor and modifier functions for the %expirationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp expirationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< expirationTime_type > expirationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expirationTime_type, char > expirationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const expirationTime_optional&
    expirationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    expirationTime_optional&
    expirationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    expirationTime (const expirationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    expirationTime (const expirationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    expirationTime (::std::unique_ptr< expirationTime_type > p);

    //@}

    /**
     * @name link
     *
     * @brief Accessor and modifier functions for the %link
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::uri link_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< link_type > link_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const link_optional&
    link () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    link_optional&
    link ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    link (const link_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    link (const link_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    link (::std::unique_ptr< link_type > p);

    //@}

    /**
     * @name dynamicAuthorizationConsultationIDs
     *
     * @brief Accessor and modifier functions for the %dynamicAuthorizationConsultationIDs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs dynamicAuthorizationConsultationIDs_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< dynamicAuthorizationConsultationIDs_type > dynamicAuthorizationConsultationIDs_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< dynamicAuthorizationConsultationIDs_type, char > dynamicAuthorizationConsultationIDs_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const dynamicAuthorizationConsultationIDs_optional&
    dynamicAuthorizationConsultationIDs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    dynamicAuthorizationConsultationIDs_optional&
    dynamicAuthorizationConsultationIDs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    dynamicAuthorizationConsultationIDs (const dynamicAuthorizationConsultationIDs_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    dynamicAuthorizationConsultationIDs (const dynamicAuthorizationConsultationIDs_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    dynamicAuthorizationConsultationIDs (::std::unique_ptr< dynamicAuthorizationConsultationIDs_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    announcedResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedResource (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedResource (const announcedResource& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announcedResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedResource&
    operator= (const announcedResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~announcedResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    accessControlPolicyIDs_optional accessControlPolicyIDs_;
    expirationTime_optional expirationTime_;
    link_optional link_;
    dynamicAuthorizationConsultationIDs_optional dynamicAuthorizationConsultationIDs_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %announceableSubordinateResource schema type.
   *
   * @nosubgrouping
   */
  class announceableSubordinateResource: public ::onem2m::resource
  {
    public:
    /**
     * @name expirationTime
     *
     * @brief Accessor and modifier functions for the %expirationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp expirationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< expirationTime_type > expirationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expirationTime_type, char > expirationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const expirationTime_optional&
    expirationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    expirationTime_optional&
    expirationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    expirationTime (const expirationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    expirationTime (const expirationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    expirationTime (::std::unique_ptr< expirationTime_type > p);

    //@}

    /**
     * @name announceTo
     *
     * @brief Accessor and modifier functions for the %announceTo
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs announceTo_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< announceTo_type > announceTo_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< announceTo_type, char > announceTo_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const announceTo_optional&
    announceTo () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    announceTo_optional&
    announceTo ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    announceTo (const announceTo_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    announceTo (const announceTo_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    announceTo (::std::unique_ptr< announceTo_type > p);

    //@}

    /**
     * @name announcedAttribute
     *
     * @brief Accessor and modifier functions for the %announcedAttribute
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::announcedAttribute1 announcedAttribute_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< announcedAttribute_type > announcedAttribute_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< announcedAttribute_type, char > announcedAttribute_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const announcedAttribute_optional&
    announcedAttribute () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    announcedAttribute_optional&
    announcedAttribute ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    announcedAttribute (const announcedAttribute_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    announcedAttribute (const announcedAttribute_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    announcedAttribute (::std::unique_ptr< announcedAttribute_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    announceableSubordinateResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announceableSubordinateResource (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announceableSubordinateResource (const announceableSubordinateResource& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announceableSubordinateResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announceableSubordinateResource&
    operator= (const announceableSubordinateResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~announceableSubordinateResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    expirationTime_optional expirationTime_;
    announceTo_optional announceTo_;
    announcedAttribute_optional announcedAttribute_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %subordinateResource schema type.
   *
   * @nosubgrouping
   */
  class subordinateResource: public ::onem2m::resource
  {
    public:
    /**
     * @name expirationTime
     *
     * @brief Accessor and modifier functions for the %expirationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp expirationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< expirationTime_type > expirationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expirationTime_type, char > expirationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const expirationTime_optional&
    expirationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    expirationTime_optional&
    expirationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    expirationTime (const expirationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    expirationTime (const expirationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    expirationTime (::std::unique_ptr< expirationTime_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    subordinateResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    subordinateResource (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    subordinateResource (const subordinateResource& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual subordinateResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    subordinateResource&
    operator= (const subordinateResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~subordinateResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    expirationTime_optional expirationTime_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %announcedSubordinateResource schema type.
   *
   * @nosubgrouping
   */
  class announcedSubordinateResource: public ::onem2m::resource
  {
    public:
    /**
     * @name expirationTime
     *
     * @brief Accessor and modifier functions for the %expirationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp expirationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< expirationTime_type > expirationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expirationTime_type, char > expirationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const expirationTime_optional&
    expirationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    expirationTime_optional&
    expirationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    expirationTime (const expirationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    expirationTime (const expirationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    expirationTime (::std::unique_ptr< expirationTime_type > p);

    //@}

    /**
     * @name link
     *
     * @brief Accessor and modifier functions for the %link
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::uri link_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< link_type > link_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const link_optional&
    link () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    link_optional&
    link ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    link (const link_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    link (const link_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    link (::std::unique_ptr< link_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    announcedSubordinateResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedSubordinateResource (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedSubordinateResource (const announcedSubordinateResource& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announcedSubordinateResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedSubordinateResource&
    operator= (const announcedSubordinateResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~announcedSubordinateResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    expirationTime_optional expirationTime_;
    link_optional link_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %listOfNCNames_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class listOfNCNames_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::ncname, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    listOfNCNames_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    listOfNCNames_base (size_type n, const ::xml_schema::ncname& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    listOfNCNames_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::ncname, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfNCNames_base (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfNCNames_base (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfNCNames_base (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfNCNames_base (const listOfNCNames_base& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfNCNames_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfNCNames_base ();
  };

  /**
   * @brief Class corresponding to the %listOfNCNames schema type.
   *
   * @nosubgrouping
   */
  class listOfNCNames: public ::onem2m::listOfNCNames_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    listOfNCNames ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    listOfNCNames (const ::onem2m::listOfNCNames_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfNCNames (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfNCNames (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    listOfNCNames (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    listOfNCNames (const listOfNCNames& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual listOfNCNames*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~listOfNCNames ();
  };

  /**
   * @brief Class corresponding to the %flexContainerResource schema type.
   *
   * @nosubgrouping
   */
  class flexContainerResource: public ::xml_schema::type
  {
    public:
    /**
     * @name resourceType
     *
     * @brief Accessor and modifier functions for the %resourceType
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::resourceType resourceType_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< resourceType_type > resourceType_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< resourceType_type, char > resourceType_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const resourceType_optional&
    resourceType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    resourceType_optional&
    resourceType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    resourceType (const resourceType_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    resourceType (const resourceType_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    resourceType (::std::unique_ptr< resourceType_type > p);

    //@}

    /**
     * @name resourceID
     *
     * @brief Accessor and modifier functions for the %resourceID
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::ID resourceID_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< resourceID_type > resourceID_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< resourceID_type, char > resourceID_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const resourceID_optional&
    resourceID () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    resourceID_optional&
    resourceID ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    resourceID (const resourceID_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    resourceID (const resourceID_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    resourceID (::std::unique_ptr< resourceID_type > p);

    //@}

    /**
     * @name parentID
     *
     * @brief Accessor and modifier functions for the %parentID
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::nhURI parentID_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< parentID_type > parentID_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< parentID_type, char > parentID_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const parentID_optional&
    parentID () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    parentID_optional&
    parentID ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    parentID (const parentID_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    parentID (const parentID_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    parentID (::std::unique_ptr< parentID_type > p);

    //@}

    /**
     * @name creationTime
     *
     * @brief Accessor and modifier functions for the %creationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp creationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< creationTime_type > creationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< creationTime_type, char > creationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const creationTime_optional&
    creationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    creationTime_optional&
    creationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    creationTime (const creationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    creationTime (const creationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    creationTime (::std::unique_ptr< creationTime_type > p);

    //@}

    /**
     * @name lastModifiedTime
     *
     * @brief Accessor and modifier functions for the %lastModifiedTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp lastModifiedTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< lastModifiedTime_type > lastModifiedTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< lastModifiedTime_type, char > lastModifiedTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const lastModifiedTime_optional&
    lastModifiedTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    lastModifiedTime_optional&
    lastModifiedTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    lastModifiedTime (const lastModifiedTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    lastModifiedTime (const lastModifiedTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    lastModifiedTime (::std::unique_ptr< lastModifiedTime_type > p);

    //@}

    /**
     * @name labels
     *
     * @brief Accessor and modifier functions for the %labels
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::labels labels_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< labels_type > labels_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< labels_type, char > labels_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const labels_optional&
    labels () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    labels_optional&
    labels ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    labels (const labels_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    labels (const labels_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    labels (::std::unique_ptr< labels_type > p);

    //@}

    /**
     * @name accessControlPolicyIDs
     *
     * @brief Accessor and modifier functions for the %accessControlPolicyIDs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::acpType accessControlPolicyIDs_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< accessControlPolicyIDs_type > accessControlPolicyIDs_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlPolicyIDs_type, char > accessControlPolicyIDs_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const accessControlPolicyIDs_optional&
    accessControlPolicyIDs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    accessControlPolicyIDs_optional&
    accessControlPolicyIDs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlPolicyIDs (const accessControlPolicyIDs_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    accessControlPolicyIDs (const accessControlPolicyIDs_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    accessControlPolicyIDs (::std::unique_ptr< accessControlPolicyIDs_type > p);

    //@}

    /**
     * @name expirationTime
     *
     * @brief Accessor and modifier functions for the %expirationTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::timestamp expirationTime_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< expirationTime_type > expirationTime_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< expirationTime_type, char > expirationTime_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const expirationTime_optional&
    expirationTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    expirationTime_optional&
    expirationTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    expirationTime (const expirationTime_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    expirationTime (const expirationTime_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    expirationTime (::std::unique_ptr< expirationTime_type > p);

    //@}

    /**
     * @name dynamicAuthorizationConsultationIDs
     *
     * @brief Accessor and modifier functions for the %dynamicAuthorizationConsultationIDs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs dynamicAuthorizationConsultationIDs_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< dynamicAuthorizationConsultationIDs_type > dynamicAuthorizationConsultationIDs_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< dynamicAuthorizationConsultationIDs_type, char > dynamicAuthorizationConsultationIDs_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const dynamicAuthorizationConsultationIDs_optional&
    dynamicAuthorizationConsultationIDs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    dynamicAuthorizationConsultationIDs_optional&
    dynamicAuthorizationConsultationIDs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    dynamicAuthorizationConsultationIDs (const dynamicAuthorizationConsultationIDs_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    dynamicAuthorizationConsultationIDs (const dynamicAuthorizationConsultationIDs_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    dynamicAuthorizationConsultationIDs (::std::unique_ptr< dynamicAuthorizationConsultationIDs_type > p);

    //@}

    /**
     * @name announceTo
     *
     * @brief Accessor and modifier functions for the %announceTo
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfURIs announceTo_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< announceTo_type > announceTo_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< announceTo_type, char > announceTo_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const announceTo_optional&
    announceTo () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    announceTo_optional&
    announceTo ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    announceTo (const announceTo_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    announceTo (const announceTo_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    announceTo (::std::unique_ptr< announceTo_type > p);

    //@}

    /**
     * @name announcedAttribute
     *
     * @brief Accessor and modifier functions for the %announcedAttribute
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::listOfNCNames announcedAttribute_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< announcedAttribute_type > announcedAttribute_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< announcedAttribute_type, char > announcedAttribute_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const announcedAttribute_optional&
    announcedAttribute () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    announcedAttribute_optional&
    announcedAttribute ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    announcedAttribute (const announcedAttribute_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    announcedAttribute (const announcedAttribute_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    announcedAttribute (::std::unique_ptr< announcedAttribute_type > p);

    //@}

    /**
     * @name stateTag
     *
     * @brief Accessor and modifier functions for the %stateTag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::non_negative_integer stateTag_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< stateTag_type > stateTag_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< stateTag_type, char > stateTag_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const stateTag_optional&
    stateTag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    stateTag_optional&
    stateTag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    stateTag (const stateTag_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    stateTag (const stateTag_optional& x);

    //@}

    /**
     * @name creator
     *
     * @brief Accessor and modifier functions for the %creator
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::ID creator_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< creator_type > creator_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< creator_type, char > creator_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const creator_optional&
    creator () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    creator_optional&
    creator ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    creator (const creator_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    creator (const creator_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    creator (::std::unique_ptr< creator_type > p);

    //@}

    /**
     * @name containerDefinition
     *
     * @brief Accessor and modifier functions for the %containerDefinition
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::uri containerDefinition_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< containerDefinition_type > containerDefinition_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< containerDefinition_type, char > containerDefinition_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const containerDefinition_optional&
    containerDefinition () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    containerDefinition_optional&
    containerDefinition ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    containerDefinition (const containerDefinition_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    containerDefinition (const containerDefinition_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    containerDefinition (::std::unique_ptr< containerDefinition_type > p);

    //@}

    /**
     * @name ontologyRef
     *
     * @brief Accessor and modifier functions for the %ontologyRef
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::uri ontologyRef_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ontologyRef_type > ontologyRef_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ontologyRef_type, char > ontologyRef_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ontologyRef_optional&
    ontologyRef () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ontologyRef_optional&
    ontologyRef ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    ontologyRef (const ontologyRef_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    ontologyRef (const ontologyRef_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    ontologyRef (::std::unique_ptr< ontologyRef_type > p);

    //@}

    /**
     * @name resourceName
     *
     * @brief Accessor and modifier functions for the %resourceName
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::onem2m::resourceName resourceName_type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< resourceName_type > resourceName_optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< resourceName_type, char > resourceName_traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const resourceName_optional&
    resourceName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    resourceName_optional&
    resourceName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    resourceName (const resourceName_type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    resourceName (const resourceName_optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    resourceName (::std::unique_ptr< resourceName_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    flexContainerResource ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    flexContainerResource (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    flexContainerResource (const flexContainerResource& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual flexContainerResource*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    flexContainerResource&
    operator= (const flexContainerResource& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~flexContainerResource ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    resourceType_optional resourceType_;
    resourceID_optional resourceID_;
    parentID_optional parentID_;
    creationTime_optional creationTime_;
    lastModifiedTime_optional lastModifiedTime_;
    labels_optional labels_;
    accessControlPolicyIDs_optional accessControlPolicyIDs_;
    expirationTime_optional expirationTime_;
    dynamicAuthorizationConsultationIDs_optional dynamicAuthorizationConsultationIDs_;
    announceTo_optional announceTo_;
    announcedAttribute_optional announcedAttribute_;
    stateTag_optional stateTag_;
    creator_optional creator_;
    containerDefinition_optional containerDefinition_;
    ontologyRef_optional ontologyRef_;
    resourceName_optional resourceName_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %absRelTimestamp_member schema type.
   *
   * @nosubgrouping
   */
  class absRelTimestamp_member: public ::onem2m::timestamp
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    absRelTimestamp_member ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    absRelTimestamp_member (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    absRelTimestamp_member (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    absRelTimestamp_member (const ::xml_schema::string&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp_member (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp_member (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp_member (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    absRelTimestamp_member (const absRelTimestamp_member& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual absRelTimestamp_member*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~absRelTimestamp_member ();
  };

  /**
   * @brief Class corresponding to the %absRelTimestamp_member1 schema type.
   *
   * @nosubgrouping
   */
  class absRelTimestamp_member1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    absRelTimestamp_member1 (const ::xml_schema::long_&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp_member1 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp_member1 (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    absRelTimestamp_member1 (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    absRelTimestamp_member1 (const absRelTimestamp_member1& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual absRelTimestamp_member1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~absRelTimestamp_member1 ();
  };

  /**
   * @brief Class corresponding to the %accessControlContexts schema type.
   *
   * @nosubgrouping
   */
  class accessControlContexts: public ::xml_schema::type
  {
    public:
    /**
     * @name accessControlWindow
     *
     * @brief Accessor and modifier functions for the %accessControlWindow
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::scheduleEntry accessControlWindow_type;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< accessControlWindow_type > accessControlWindow_sequence;

    /**
     * @brief Element iterator type.
     */
    typedef accessControlWindow_sequence::iterator accessControlWindow_iterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef accessControlWindow_sequence::const_iterator accessControlWindow_const_iterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlWindow_type, char > accessControlWindow_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const accessControlWindow_sequence&
    accessControlWindow () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    accessControlWindow_sequence&
    accessControlWindow ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    accessControlWindow (const accessControlWindow_sequence& s);

    //@}

    /**
     * @name accessControlIpAddresses
     *
     * @brief Accessor and modifier functions for the %accessControlIpAddresses
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::accessControlIpAddresses accessControlIpAddresses_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< accessControlIpAddresses_type > accessControlIpAddresses_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlIpAddresses_type, char > accessControlIpAddresses_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const accessControlIpAddresses_optional&
    accessControlIpAddresses () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    accessControlIpAddresses_optional&
    accessControlIpAddresses ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlIpAddresses (const accessControlIpAddresses_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    accessControlIpAddresses (const accessControlIpAddresses_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    accessControlIpAddresses (::std::unique_ptr< accessControlIpAddresses_type > p);

    //@}

    /**
     * @name accessControlLocationRegion
     *
     * @brief Accessor and modifier functions for the %accessControlLocationRegion
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::locationRegion accessControlLocationRegion_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< accessControlLocationRegion_type > accessControlLocationRegion_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< accessControlLocationRegion_type, char > accessControlLocationRegion_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const accessControlLocationRegion_optional&
    accessControlLocationRegion () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    accessControlLocationRegion_optional&
    accessControlLocationRegion ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    accessControlLocationRegion (const accessControlLocationRegion_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    accessControlLocationRegion (const accessControlLocationRegion_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    accessControlLocationRegion (::std::unique_ptr< accessControlLocationRegion_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    accessControlContexts ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    accessControlContexts (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    accessControlContexts (const accessControlContexts& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual accessControlContexts*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    accessControlContexts&
    operator= (const accessControlContexts& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~accessControlContexts ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    accessControlWindow_sequence accessControlWindow_;
    accessControlIpAddresses_optional accessControlIpAddresses_;
    accessControlLocationRegion_optional accessControlLocationRegion_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %notificationURI_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class notificationURI_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::uri, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    notificationURI_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    notificationURI_base (size_type n, const ::xml_schema::uri& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    notificationURI_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::uri, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    notificationURI_base (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    notificationURI_base (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    notificationURI_base (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    notificationURI_base (const notificationURI_base& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual notificationURI_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~notificationURI_base ();
  };

  /**
   * @brief Class corresponding to the %notificationURI schema type.
   *
   * @nosubgrouping
   */
  class notificationURI: public ::onem2m::notificationURI_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    notificationURI ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    notificationURI (const ::onem2m::notificationURI_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    notificationURI (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    notificationURI (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    notificationURI (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    notificationURI (const notificationURI& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual notificationURI*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~notificationURI ();
  };

  /**
   * @brief Class corresponding to the %URIReference schema type.
   *
   * @nosubgrouping
   */
  class URIReference: public ::xml_schema::type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::ncname name_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const name_type&
    name () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    name_type&
    name ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    name (const name_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    name (::std::unique_ptr< name_type > p);

    //@}

    /**
     * @name URI
     *
     * @brief Accessor and modifier functions for the %URI
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::uri URI_type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< URI_type, char > URI_traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const URI_type&
    URI () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    URI_type&
    URI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    URI (const URI_type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    URI (::std::unique_ptr< URI_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    URIReference (const name_type&,
                  const URI_type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    URIReference (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    URIReference (const URIReference& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual URIReference*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    URIReference&
    operator= (const URIReference& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~URIReference ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< URI_type > URI_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %countryCode1_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class countryCode1_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::countryCode, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    countryCode1_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    countryCode1_base (size_type n, const ::onem2m::countryCode& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    countryCode1_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::countryCode, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode1_base (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode1_base (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode1_base (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    countryCode1_base (const countryCode1_base& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual countryCode1_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~countryCode1_base ();
  };

  /**
   * @brief Class corresponding to the %countryCode1 schema type.
   *
   * @nosubgrouping
   */
  class countryCode1: public ::onem2m::countryCode1_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    countryCode1 ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    countryCode1 (const ::onem2m::countryCode1_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode1 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    countryCode1 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    countryCode1 (const countryCode1& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual countryCode1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~countryCode1 ();
  };

  /**
   * @brief List class corresponding to the %circRegion_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class circRegion_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::float_, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    circRegion_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    circRegion_base (size_type n, const ::xml_schema::float_& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    circRegion_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    circRegion_base (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    circRegion_base (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    circRegion_base (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    circRegion_base (const circRegion_base& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual circRegion_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~circRegion_base ();
  };

  /**
   * @brief Class corresponding to the %circRegion schema type.
   *
   * @nosubgrouping
   */
  class circRegion: public ::onem2m::circRegion_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    circRegion ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    circRegion (const ::onem2m::circRegion_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    circRegion (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    circRegion (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    circRegion (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    circRegion (const circRegion& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual circRegion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~circRegion ();
  };

  /**
   * @brief List class corresponding to the %announcedAttribute_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class announcedAttribute_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::ncname, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    announcedAttribute_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    announcedAttribute_base (size_type n, const ::xml_schema::ncname& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    announcedAttribute_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::ncname, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute_base (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute_base (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute_base (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedAttribute_base (const announcedAttribute_base& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announcedAttribute_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~announcedAttribute_base ();
  };

  /**
   * @brief Class corresponding to the %announcedAttribute schema type.
   *
   * @nosubgrouping
   */
  class announcedAttribute: public ::onem2m::announcedAttribute_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    announcedAttribute ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    announcedAttribute (const ::onem2m::announcedAttribute_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedAttribute (const announcedAttribute& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announcedAttribute*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~announcedAttribute ();
  };

  /**
   * @brief List class corresponding to the %announcedAttribute1_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class announcedAttribute1_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::ncname, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    announcedAttribute1_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    announcedAttribute1_base (size_type n, const ::xml_schema::ncname& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    announcedAttribute1_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::ncname, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute1_base (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute1_base (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute1_base (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedAttribute1_base (const announcedAttribute1_base& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announcedAttribute1_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~announcedAttribute1_base ();
  };

  /**
   * @brief Class corresponding to the %announcedAttribute1 schema type.
   *
   * @nosubgrouping
   */
  class announcedAttribute1: public ::onem2m::announcedAttribute1_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    announcedAttribute1 ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    announcedAttribute1 (const ::onem2m::announcedAttribute1_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute1 (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute1 (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    announcedAttribute1 (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    announcedAttribute1 (const announcedAttribute1& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual announcedAttribute1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~announcedAttribute1 ();
  };

  /**
   * @brief Class corresponding to the %accessControlIpAddresses schema type.
   *
   * @nosubgrouping
   */
  class accessControlIpAddresses: public ::xml_schema::type
  {
    public:
    /**
     * @name ipv4Addresses
     *
     * @brief Accessor and modifier functions for the %ipv4Addresses
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::ipv4Addresses ipv4Addresses_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ipv4Addresses_type > ipv4Addresses_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ipv4Addresses_type, char > ipv4Addresses_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ipv4Addresses_optional&
    ipv4Addresses () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ipv4Addresses_optional&
    ipv4Addresses ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    ipv4Addresses (const ipv4Addresses_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    ipv4Addresses (const ipv4Addresses_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    ipv4Addresses (::std::unique_ptr< ipv4Addresses_type > p);

    //@}

    /**
     * @name ipv6Addresses
     *
     * @brief Accessor and modifier functions for the %ipv6Addresses
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::onem2m::ipv6Addresses ipv6Addresses_type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ipv6Addresses_type > ipv6Addresses_optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ipv6Addresses_type, char > ipv6Addresses_traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ipv6Addresses_optional&
    ipv6Addresses () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ipv6Addresses_optional&
    ipv6Addresses ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    ipv6Addresses (const ipv6Addresses_type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    ipv6Addresses (const ipv6Addresses_optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    ipv6Addresses (::std::unique_ptr< ipv6Addresses_type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    accessControlIpAddresses ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    accessControlIpAddresses (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    accessControlIpAddresses (const accessControlIpAddresses& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual accessControlIpAddresses*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    accessControlIpAddresses&
    operator= (const accessControlIpAddresses& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~accessControlIpAddresses ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ipv4Addresses_optional ipv4Addresses_;
    ipv6Addresses_optional ipv6Addresses_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %ipv4Addresses_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class ipv4Addresses_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::ipv4, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    ipv4Addresses_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    ipv4Addresses_base (size_type n, const ::onem2m::ipv4& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    ipv4Addresses_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::ipv4, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4Addresses_base (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4Addresses_base (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4Addresses_base (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ipv4Addresses_base (const ipv4Addresses_base& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ipv4Addresses_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~ipv4Addresses_base ();
  };

  /**
   * @brief Class corresponding to the %ipv4Addresses schema type.
   *
   * @nosubgrouping
   */
  class ipv4Addresses: public ::onem2m::ipv4Addresses_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    ipv4Addresses ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ipv4Addresses (const ::onem2m::ipv4Addresses_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4Addresses (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4Addresses (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv4Addresses (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ipv4Addresses (const ipv4Addresses& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ipv4Addresses*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ipv4Addresses ();
  };

  /**
   * @brief List class corresponding to the %ipv6Addresses_base
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   */
  class ipv6Addresses_base: public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::onem2m::ipv6, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    ipv6Addresses_base ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    ipv6Addresses_base (size_type n, const ::onem2m::ipv6& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    ipv6Addresses_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::onem2m::ipv6, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6Addresses_base (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6Addresses_base (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6Addresses_base (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ipv6Addresses_base (const ipv6Addresses_base& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ipv6Addresses_base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~ipv6Addresses_base ();
  };

  /**
   * @brief Class corresponding to the %ipv6Addresses schema type.
   *
   * @nosubgrouping
   */
  class ipv6Addresses: public ::onem2m::ipv6Addresses_base
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    ipv6Addresses ();

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ipv6Addresses (const ::onem2m::ipv6Addresses_base&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6Addresses (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6Addresses (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ipv6Addresses (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ipv6Addresses (const ipv6Addresses& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ipv6Addresses*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ipv6Addresses ();
  };
}

#include <iosfwd>

namespace onem2m
{
  ::std::ostream&
  operator<< (::std::ostream&, const ID&);

  ::std::ostream&
  operator<< (::std::ostream&, const nodeID&);

  ::std::ostream&
  operator<< (::std::ostream&, const deviceID&);

  ::std::ostream&
  operator<< (::std::ostream&, const externalID&);

  ::std::ostream&
  operator<< (::std::ostream&, const requestID&);

  ::std::ostream&
  operator<< (::std::ostream&, const roleID&);

  ::std::ostream&
  operator<< (::std::ostream&, const tokenID&);

  ::std::ostream&
  operator<< (::std::ostream&, const nhURI&);

  ::std::ostream&
  operator<< (::std::ostream&, const acpType_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const acpType&);

  ::std::ostream&
  operator<< (::std::ostream&, const labels_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const labels&);

  ::std::ostream&
  operator<< (::std::ostream&, const triggerRecipientID&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfM2MID_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfM2MID&);

  ::std::ostream&
  operator<< (::std::ostream&, const ipv4&);

  ::std::ostream&
  operator<< (::std::ostream&, const ipv6&);

  ::std::ostream&
  operator<< (::std::ostream&, const poaList_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const poaList&);

  ::std::ostream&
  operator<< (::std::ostream&, const timestamp&);

  ::std::ostream&
  operator<< (::std::ostream&, const absRelTimestamp&);

  ::std::ostream&
  operator<< (::std::ostream&, const typeOfContent&);

  ::std::ostream&
  operator<< (::std::ostream&, permittedMediaTypes::value);

  ::std::ostream&
  operator<< (::std::ostream&, const permittedMediaTypes&);

  ::std::ostream&
  operator<< (::std::ostream&, const serializations_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const serializations&);

  ::std::ostream&
  operator<< (::std::ostream&, const contentInfo&);

  ::std::ostream&
  operator<< (::std::ostream&, const scheduleEntry&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfURIs_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfURIs&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfDuration&);

  ::std::ostream&
  operator<< (::std::ostream&, const attributeList&);

  ::std::ostream&
  operator<< (::std::ostream&, const resourceTypeList_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const resourceTypeList&);

  ::std::ostream&
  operator<< (::std::ostream&, const sparql&);

  ::std::ostream&
  operator<< (::std::ostream&, const resourceName&);

  ::std::ostream&
  operator<< (::std::ostream&, const attribute&);

  ::std::ostream&
  operator<< (::std::ostream&, const scheduleEntries&);

  ::std::ostream&
  operator<< (::std::ostream&, const setOfAcrs&);

  ::std::ostream&
  operator<< (::std::ostream&, const accessControlRule&);

  ::std::ostream&
  operator<< (::std::ostream&, const responseTypeInfo&);

  ::std::ostream&
  operator<< (::std::ostream&, const contentRef&);

  ::std::ostream&
  operator<< (::std::ostream&, const locationRegion&);

  ::std::ostream&
  operator<< (::std::ostream&, const countryCode&);

  ::std::ostream&
  operator<< (::std::ostream&, const missingData&);

  ::std::ostream&
  operator<< (::std::ostream&, const dataLink&);

  ::std::ostream&
  operator<< (::std::ostream&, const resource&);

  ::std::ostream&
  operator<< (::std::ostream&, const regularResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const announceableResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const announcedResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const announceableSubordinateResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const subordinateResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const announcedSubordinateResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfNCNames_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const listOfNCNames&);

  ::std::ostream&
  operator<< (::std::ostream&, const flexContainerResource&);

  ::std::ostream&
  operator<< (::std::ostream&, const absRelTimestamp_member&);

  ::std::ostream&
  operator<< (::std::ostream&, const absRelTimestamp_member1&);

  ::std::ostream&
  operator<< (::std::ostream&, const accessControlContexts&);

  ::std::ostream&
  operator<< (::std::ostream&, const notificationURI_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const notificationURI&);

  ::std::ostream&
  operator<< (::std::ostream&, const URIReference&);

  ::std::ostream&
  operator<< (::std::ostream&, const countryCode1_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const countryCode1&);

  ::std::ostream&
  operator<< (::std::ostream&, const circRegion_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const circRegion&);

  ::std::ostream&
  operator<< (::std::ostream&, const announcedAttribute_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const announcedAttribute&);

  ::std::ostream&
  operator<< (::std::ostream&, const announcedAttribute1_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const announcedAttribute1&);

  ::std::ostream&
  operator<< (::std::ostream&, const accessControlIpAddresses&);

  ::std::ostream&
  operator<< (::std::ostream&, const ipv4Addresses_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const ipv4Addresses&);

  ::std::ostream&
  operator<< (::std::ostream&, const ipv6Addresses_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const ipv6Addresses&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace onem2m
{
  /**
   * @name Parsing functions for the %sg_resource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::resource >
  sg_resource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_regularResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (const ::std::string& uri,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (const ::std::string& uri,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (const ::std::string& uri,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::std::istream& is,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::std::istream& is,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::std::istream& is,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::std::istream& is,
                      const ::std::string& id,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::std::istream& is,
                      const ::std::string& id,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::std::istream& is,
                      const ::std::string& id,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::xercesc::InputSource& is,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::xercesc::InputSource& is,
                      ::xml_schema::error_handler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::xercesc::InputSource& is,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::regularResource >
  sg_regularResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f = 0,
                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_announcedResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (const ::std::string& uri,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (const ::std::string& uri,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (const ::std::string& uri,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::std::istream& is,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::std::istream& is,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::std::istream& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::std::istream& is,
                        const ::std::string& id,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::xercesc::InputSource& is,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::xercesc::InputSource& is,
                        ::xml_schema::error_handler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::xercesc::InputSource& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::announcedResource >
  sg_announcedResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f = 0,
                        const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_announceableResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (const ::std::string& uri,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (const ::std::string& uri,
                           ::xml_schema::error_handler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (const ::std::string& uri,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::std::istream& is,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::std::istream& is,
                           ::xml_schema::error_handler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::std::istream& is,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::std::istream& is,
                           const ::std::string& id,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::std::istream& is,
                           const ::std::string& id,
                           ::xml_schema::error_handler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::std::istream& is,
                           const ::std::string& id,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::xercesc::InputSource& is,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::xercesc::InputSource& is,
                           ::xml_schema::error_handler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::xercesc::InputSource& is,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::announceableResource >
  sg_announceableResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f = 0,
                           const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_subordinateResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (const ::std::string& uri,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (const ::std::string& uri,
                          ::xml_schema::error_handler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (const ::std::string& uri,
                          ::xercesc::DOMErrorHandler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::std::istream& is,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::std::istream& is,
                          ::xml_schema::error_handler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::std::istream& is,
                          ::xercesc::DOMErrorHandler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::std::istream& is,
                          const ::std::string& id,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::std::istream& is,
                          const ::std::string& id,
                          ::xml_schema::error_handler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::std::istream& is,
                          const ::std::string& id,
                          ::xercesc::DOMErrorHandler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::xercesc::InputSource& is,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::xercesc::InputSource& is,
                          ::xml_schema::error_handler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::xercesc::InputSource& is,
                          ::xercesc::DOMErrorHandler& eh,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::subordinateResource >
  sg_subordinateResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::flags f = 0,
                          const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_announceableSubordinateResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (const ::std::string& uri,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (const ::std::string& uri,
                                      ::xml_schema::error_handler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (const ::std::string& uri,
                                      ::xercesc::DOMErrorHandler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::std::istream& is,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::std::istream& is,
                                      ::xml_schema::error_handler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::std::istream& is,
                                      ::xercesc::DOMErrorHandler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::std::istream& is,
                                      const ::std::string& id,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::std::istream& is,
                                      const ::std::string& id,
                                      ::xml_schema::error_handler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::std::istream& is,
                                      const ::std::string& id,
                                      ::xercesc::DOMErrorHandler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::xercesc::InputSource& is,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::xercesc::InputSource& is,
                                      ::xml_schema::error_handler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::xercesc::InputSource& is,
                                      ::xercesc::DOMErrorHandler& eh,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (const ::xercesc::DOMDocument& d,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::announceableSubordinateResource >
  sg_announceableSubordinateResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                      ::xml_schema::flags f = 0,
                                      const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_announcedSubordinateResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (const ::std::string& uri,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (const ::std::string& uri,
                                   ::xml_schema::error_handler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (const ::std::string& uri,
                                   ::xercesc::DOMErrorHandler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::std::istream& is,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::std::istream& is,
                                   ::xml_schema::error_handler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::std::istream& is,
                                   const ::std::string& id,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::std::istream& is,
                                   const ::std::string& id,
                                   ::xml_schema::error_handler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::std::istream& is,
                                   const ::std::string& id,
                                   ::xercesc::DOMErrorHandler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::xercesc::InputSource& is,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::xercesc::InputSource& is,
                                   ::xml_schema::error_handler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::xercesc::InputSource& is,
                                   ::xercesc::DOMErrorHandler& eh,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::announcedSubordinateResource >
  sg_announcedSubordinateResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                   ::xml_schema::flags f = 0,
                                   const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %sg_flexContainerResource document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (const ::std::string& uri,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (const ::std::string& uri,
                            ::xml_schema::error_handler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (const ::std::string& uri,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::std::istream& is,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::std::istream& is,
                            ::xml_schema::error_handler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::std::istream& is,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::std::istream& is,
                            const ::std::string& id,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::std::istream& is,
                            const ::std::string& id,
                            ::xml_schema::error_handler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::std::istream& is,
                            const ::std::string& id,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::xercesc::InputSource& is,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::xercesc::InputSource& is,
                            ::xml_schema::error_handler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::xercesc::InputSource& is,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::flexContainerResource >
  sg_flexContainerResource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::flags f = 0,
                            const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}

  /**
   * @name Parsing functions for the %listOfURIs document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::onem2m::listOfURIs >
  listOfURIs_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace onem2m
{
  void
  operator<< (::xercesc::DOMElement&, const ID&);

  void
  operator<< (::xercesc::DOMAttr&, const ID&);

  void
  operator<< (::xml_schema::list_stream&,
              const ID&);

  void
  operator<< (::xercesc::DOMElement&, const nodeID&);

  void
  operator<< (::xercesc::DOMAttr&, const nodeID&);

  void
  operator<< (::xml_schema::list_stream&,
              const nodeID&);

  void
  operator<< (::xercesc::DOMElement&, const deviceID&);

  void
  operator<< (::xercesc::DOMAttr&, const deviceID&);

  void
  operator<< (::xml_schema::list_stream&,
              const deviceID&);

  void
  operator<< (::xercesc::DOMElement&, const externalID&);

  void
  operator<< (::xercesc::DOMAttr&, const externalID&);

  void
  operator<< (::xml_schema::list_stream&,
              const externalID&);

  void
  operator<< (::xercesc::DOMElement&, const requestID&);

  void
  operator<< (::xercesc::DOMAttr&, const requestID&);

  void
  operator<< (::xml_schema::list_stream&,
              const requestID&);

  void
  operator<< (::xercesc::DOMElement&, const roleID&);

  void
  operator<< (::xercesc::DOMAttr&, const roleID&);

  void
  operator<< (::xml_schema::list_stream&,
              const roleID&);

  void
  operator<< (::xercesc::DOMElement&, const tokenID&);

  void
  operator<< (::xercesc::DOMAttr&, const tokenID&);

  void
  operator<< (::xml_schema::list_stream&,
              const tokenID&);

  void
  operator<< (::xercesc::DOMElement&, const nhURI&);

  void
  operator<< (::xercesc::DOMAttr&, const nhURI&);

  void
  operator<< (::xml_schema::list_stream&,
              const nhURI&);

  void
  operator<< (::xercesc::DOMElement&, const acpType_base&);

  void
  operator<< (::xercesc::DOMAttr&, const acpType_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const acpType_base&);

  void
  operator<< (::xercesc::DOMElement&, const acpType&);

  void
  operator<< (::xercesc::DOMAttr&, const acpType&);

  void
  operator<< (::xml_schema::list_stream&,
              const acpType&);

  void
  operator<< (::xercesc::DOMElement&, const labels_base&);

  void
  operator<< (::xercesc::DOMAttr&, const labels_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const labels_base&);

  void
  operator<< (::xercesc::DOMElement&, const labels&);

  void
  operator<< (::xercesc::DOMAttr&, const labels&);

  void
  operator<< (::xml_schema::list_stream&,
              const labels&);

  void
  operator<< (::xercesc::DOMElement&, const triggerRecipientID&);

  void
  operator<< (::xercesc::DOMAttr&, const triggerRecipientID&);

  void
  operator<< (::xml_schema::list_stream&,
              const triggerRecipientID&);

  void
  operator<< (::xercesc::DOMElement&, const listOfM2MID_base&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfM2MID_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfM2MID_base&);

  void
  operator<< (::xercesc::DOMElement&, const listOfM2MID&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfM2MID&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfM2MID&);

  void
  operator<< (::xercesc::DOMElement&, const ipv4&);

  void
  operator<< (::xercesc::DOMAttr&, const ipv4&);

  void
  operator<< (::xml_schema::list_stream&,
              const ipv4&);

  void
  operator<< (::xercesc::DOMElement&, const ipv6&);

  void
  operator<< (::xercesc::DOMAttr&, const ipv6&);

  void
  operator<< (::xml_schema::list_stream&,
              const ipv6&);

  void
  operator<< (::xercesc::DOMElement&, const poaList_base&);

  void
  operator<< (::xercesc::DOMAttr&, const poaList_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const poaList_base&);

  void
  operator<< (::xercesc::DOMElement&, const poaList&);

  void
  operator<< (::xercesc::DOMAttr&, const poaList&);

  void
  operator<< (::xml_schema::list_stream&,
              const poaList&);

  void
  operator<< (::xercesc::DOMElement&, const timestamp&);

  void
  operator<< (::xercesc::DOMAttr&, const timestamp&);

  void
  operator<< (::xml_schema::list_stream&,
              const timestamp&);

  void
  operator<< (::xercesc::DOMElement&, const absRelTimestamp&);

  void
  operator<< (::xercesc::DOMAttr&, const absRelTimestamp&);

  void
  operator<< (::xml_schema::list_stream&,
              const absRelTimestamp&);

  void
  operator<< (::xercesc::DOMElement&, const typeOfContent&);

  void
  operator<< (::xercesc::DOMAttr&, const typeOfContent&);

  void
  operator<< (::xml_schema::list_stream&,
              const typeOfContent&);

  void
  operator<< (::xercesc::DOMElement&, const permittedMediaTypes&);

  void
  operator<< (::xercesc::DOMAttr&, const permittedMediaTypes&);

  void
  operator<< (::xml_schema::list_stream&,
              const permittedMediaTypes&);

  void
  operator<< (::xercesc::DOMElement&, const serializations_base&);

  void
  operator<< (::xercesc::DOMAttr&, const serializations_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const serializations_base&);

  void
  operator<< (::xercesc::DOMElement&, const serializations&);

  void
  operator<< (::xercesc::DOMAttr&, const serializations&);

  void
  operator<< (::xml_schema::list_stream&,
              const serializations&);

  void
  operator<< (::xercesc::DOMElement&, const contentInfo&);

  void
  operator<< (::xercesc::DOMAttr&, const contentInfo&);

  void
  operator<< (::xml_schema::list_stream&,
              const contentInfo&);

  void
  operator<< (::xercesc::DOMElement&, const scheduleEntry&);

  void
  operator<< (::xercesc::DOMAttr&, const scheduleEntry&);

  void
  operator<< (::xml_schema::list_stream&,
              const scheduleEntry&);

  void
  operator<< (::xercesc::DOMElement&, const listOfURIs_base&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfURIs_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfURIs_base&);

  void
  operator<< (::xercesc::DOMElement&, const listOfURIs&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfURIs&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfURIs&);

  void
  operator<< (::xercesc::DOMElement&, const listOfDuration&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfDuration&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfDuration&);

  void
  operator<< (::xercesc::DOMElement&, const attributeList&);

  void
  operator<< (::xercesc::DOMAttr&, const attributeList&);

  void
  operator<< (::xml_schema::list_stream&,
              const attributeList&);

  void
  operator<< (::xercesc::DOMElement&, const resourceTypeList_base&);

  void
  operator<< (::xercesc::DOMAttr&, const resourceTypeList_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const resourceTypeList_base&);

  void
  operator<< (::xercesc::DOMElement&, const resourceTypeList&);

  void
  operator<< (::xercesc::DOMAttr&, const resourceTypeList&);

  void
  operator<< (::xml_schema::list_stream&,
              const resourceTypeList&);

  void
  operator<< (::xercesc::DOMElement&, const sparql&);

  void
  operator<< (::xercesc::DOMAttr&, const sparql&);

  void
  operator<< (::xml_schema::list_stream&,
              const sparql&);

  void
  operator<< (::xercesc::DOMElement&, const resourceName&);

  void
  operator<< (::xercesc::DOMAttr&, const resourceName&);

  void
  operator<< (::xml_schema::list_stream&,
              const resourceName&);

  void
  operator<< (::xercesc::DOMElement&, const attribute&);

  void
  operator<< (::xercesc::DOMElement&, const scheduleEntries&);

  void
  operator<< (::xercesc::DOMElement&, const setOfAcrs&);

  void
  operator<< (::xercesc::DOMElement&, const accessControlRule&);

  void
  operator<< (::xercesc::DOMElement&, const responseTypeInfo&);

  void
  operator<< (::xercesc::DOMElement&, const contentRef&);

  void
  operator<< (::xercesc::DOMElement&, const locationRegion&);

  void
  operator<< (::xercesc::DOMElement&, const countryCode&);

  void
  operator<< (::xercesc::DOMAttr&, const countryCode&);

  void
  operator<< (::xml_schema::list_stream&,
              const countryCode&);

  void
  operator<< (::xercesc::DOMElement&, const missingData&);

  void
  operator<< (::xercesc::DOMElement&, const dataLink&);

  void
  operator<< (::xercesc::DOMElement&, const resource&);

  void
  operator<< (::xercesc::DOMElement&, const regularResource&);

  void
  operator<< (::xercesc::DOMElement&, const announceableResource&);

  void
  operator<< (::xercesc::DOMElement&, const announcedResource&);

  void
  operator<< (::xercesc::DOMElement&, const announceableSubordinateResource&);

  void
  operator<< (::xercesc::DOMElement&, const subordinateResource&);

  void
  operator<< (::xercesc::DOMElement&, const announcedSubordinateResource&);

  void
  operator<< (::xercesc::DOMElement&, const listOfNCNames_base&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfNCNames_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfNCNames_base&);

  void
  operator<< (::xercesc::DOMElement&, const listOfNCNames&);

  void
  operator<< (::xercesc::DOMAttr&, const listOfNCNames&);

  void
  operator<< (::xml_schema::list_stream&,
              const listOfNCNames&);

  void
  operator<< (::xercesc::DOMElement&, const flexContainerResource&);

  /**
   * @name Serialization functions for the %sg_resource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_resource (::std::ostream& os,
               const ::onem2m::resource& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_resource (::std::ostream& os,
               const ::onem2m::resource& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_resource (::std::ostream& os,
               const ::onem2m::resource& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_resource (::xercesc::XMLFormatTarget& ft,
               const ::onem2m::resource& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_resource (::xercesc::XMLFormatTarget& ft,
               const ::onem2m::resource& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_resource (::xercesc::XMLFormatTarget& ft,
               const ::onem2m::resource& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_resource (::xercesc::DOMDocument& d,
               const ::onem2m::resource& x,
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_resource (const ::onem2m::resource& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_regularResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_regularResource (::std::ostream& os,
                      const ::onem2m::regularResource& x, 
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_regularResource (::std::ostream& os,
                      const ::onem2m::regularResource& x, 
                      ::xml_schema::error_handler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_regularResource (::std::ostream& os,
                      const ::onem2m::regularResource& x, 
                      ::xercesc::DOMErrorHandler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_regularResource (::xercesc::XMLFormatTarget& ft,
                      const ::onem2m::regularResource& x, 
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_regularResource (::xercesc::XMLFormatTarget& ft,
                      const ::onem2m::regularResource& x, 
                      ::xml_schema::error_handler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_regularResource (::xercesc::XMLFormatTarget& ft,
                      const ::onem2m::regularResource& x, 
                      ::xercesc::DOMErrorHandler& eh,
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      const ::std::string& e = "UTF-8",
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_regularResource (::xercesc::DOMDocument& d,
                      const ::onem2m::regularResource& x,
                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_regularResource (const ::onem2m::regularResource& x, 
                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                      ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_announcedResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announcedResource (::std::ostream& os,
                        const ::onem2m::announcedResource& x, 
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedResource (::std::ostream& os,
                        const ::onem2m::announcedResource& x, 
                        ::xml_schema::error_handler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedResource (::std::ostream& os,
                        const ::onem2m::announcedResource& x, 
                        ::xercesc::DOMErrorHandler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announcedResource (::xercesc::XMLFormatTarget& ft,
                        const ::onem2m::announcedResource& x, 
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedResource (::xercesc::XMLFormatTarget& ft,
                        const ::onem2m::announcedResource& x, 
                        ::xml_schema::error_handler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedResource (::xercesc::XMLFormatTarget& ft,
                        const ::onem2m::announcedResource& x, 
                        ::xercesc::DOMErrorHandler& eh,
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_announcedResource (::xercesc::DOMDocument& d,
                        const ::onem2m::announcedResource& x,
                        ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_announcedResource (const ::onem2m::announcedResource& x, 
                        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                        ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_announceableResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announceableResource (::std::ostream& os,
                           const ::onem2m::announceableResource& x, 
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableResource (::std::ostream& os,
                           const ::onem2m::announceableResource& x, 
                           ::xml_schema::error_handler& eh,
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableResource (::std::ostream& os,
                           const ::onem2m::announceableResource& x, 
                           ::xercesc::DOMErrorHandler& eh,
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announceableResource (::xercesc::XMLFormatTarget& ft,
                           const ::onem2m::announceableResource& x, 
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableResource (::xercesc::XMLFormatTarget& ft,
                           const ::onem2m::announceableResource& x, 
                           ::xml_schema::error_handler& eh,
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableResource (::xercesc::XMLFormatTarget& ft,
                           const ::onem2m::announceableResource& x, 
                           ::xercesc::DOMErrorHandler& eh,
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_announceableResource (::xercesc::DOMDocument& d,
                           const ::onem2m::announceableResource& x,
                           ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_announceableResource (const ::onem2m::announceableResource& x, 
                           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                           ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_subordinateResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_subordinateResource (::std::ostream& os,
                          const ::onem2m::subordinateResource& x, 
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_subordinateResource (::std::ostream& os,
                          const ::onem2m::subordinateResource& x, 
                          ::xml_schema::error_handler& eh,
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_subordinateResource (::std::ostream& os,
                          const ::onem2m::subordinateResource& x, 
                          ::xercesc::DOMErrorHandler& eh,
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_subordinateResource (::xercesc::XMLFormatTarget& ft,
                          const ::onem2m::subordinateResource& x, 
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_subordinateResource (::xercesc::XMLFormatTarget& ft,
                          const ::onem2m::subordinateResource& x, 
                          ::xml_schema::error_handler& eh,
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_subordinateResource (::xercesc::XMLFormatTarget& ft,
                          const ::onem2m::subordinateResource& x, 
                          ::xercesc::DOMErrorHandler& eh,
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_subordinateResource (::xercesc::DOMDocument& d,
                          const ::onem2m::subordinateResource& x,
                          ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_subordinateResource (const ::onem2m::subordinateResource& x, 
                          const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                          ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_announceableSubordinateResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announceableSubordinateResource (::std::ostream& os,
                                      const ::onem2m::announceableSubordinateResource& x, 
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      const ::std::string& e = "UTF-8",
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableSubordinateResource (::std::ostream& os,
                                      const ::onem2m::announceableSubordinateResource& x, 
                                      ::xml_schema::error_handler& eh,
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      const ::std::string& e = "UTF-8",
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableSubordinateResource (::std::ostream& os,
                                      const ::onem2m::announceableSubordinateResource& x, 
                                      ::xercesc::DOMErrorHandler& eh,
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      const ::std::string& e = "UTF-8",
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announceableSubordinateResource (::xercesc::XMLFormatTarget& ft,
                                      const ::onem2m::announceableSubordinateResource& x, 
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      const ::std::string& e = "UTF-8",
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableSubordinateResource (::xercesc::XMLFormatTarget& ft,
                                      const ::onem2m::announceableSubordinateResource& x, 
                                      ::xml_schema::error_handler& eh,
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      const ::std::string& e = "UTF-8",
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announceableSubordinateResource (::xercesc::XMLFormatTarget& ft,
                                      const ::onem2m::announceableSubordinateResource& x, 
                                      ::xercesc::DOMErrorHandler& eh,
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      const ::std::string& e = "UTF-8",
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_announceableSubordinateResource (::xercesc::DOMDocument& d,
                                      const ::onem2m::announceableSubordinateResource& x,
                                      ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_announceableSubordinateResource (const ::onem2m::announceableSubordinateResource& x, 
                                      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                      ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_announcedSubordinateResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announcedSubordinateResource (::std::ostream& os,
                                   const ::onem2m::announcedSubordinateResource& x, 
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   const ::std::string& e = "UTF-8",
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedSubordinateResource (::std::ostream& os,
                                   const ::onem2m::announcedSubordinateResource& x, 
                                   ::xml_schema::error_handler& eh,
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   const ::std::string& e = "UTF-8",
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedSubordinateResource (::std::ostream& os,
                                   const ::onem2m::announcedSubordinateResource& x, 
                                   ::xercesc::DOMErrorHandler& eh,
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   const ::std::string& e = "UTF-8",
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_announcedSubordinateResource (::xercesc::XMLFormatTarget& ft,
                                   const ::onem2m::announcedSubordinateResource& x, 
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   const ::std::string& e = "UTF-8",
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedSubordinateResource (::xercesc::XMLFormatTarget& ft,
                                   const ::onem2m::announcedSubordinateResource& x, 
                                   ::xml_schema::error_handler& eh,
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   const ::std::string& e = "UTF-8",
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_announcedSubordinateResource (::xercesc::XMLFormatTarget& ft,
                                   const ::onem2m::announcedSubordinateResource& x, 
                                   ::xercesc::DOMErrorHandler& eh,
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   const ::std::string& e = "UTF-8",
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_announcedSubordinateResource (::xercesc::DOMDocument& d,
                                   const ::onem2m::announcedSubordinateResource& x,
                                   ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_announcedSubordinateResource (const ::onem2m::announcedSubordinateResource& x, 
                                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                                   ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %sg_flexContainerResource document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_flexContainerResource (::std::ostream& os,
                            const ::onem2m::flexContainerResource& x, 
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_flexContainerResource (::std::ostream& os,
                            const ::onem2m::flexContainerResource& x, 
                            ::xml_schema::error_handler& eh,
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_flexContainerResource (::std::ostream& os,
                            const ::onem2m::flexContainerResource& x, 
                            ::xercesc::DOMErrorHandler& eh,
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  sg_flexContainerResource (::xercesc::XMLFormatTarget& ft,
                            const ::onem2m::flexContainerResource& x, 
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_flexContainerResource (::xercesc::XMLFormatTarget& ft,
                            const ::onem2m::flexContainerResource& x, 
                            ::xml_schema::error_handler& eh,
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  sg_flexContainerResource (::xercesc::XMLFormatTarget& ft,
                            const ::onem2m::flexContainerResource& x, 
                            ::xercesc::DOMErrorHandler& eh,
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  sg_flexContainerResource (::xercesc::DOMDocument& d,
                            const ::onem2m::flexContainerResource& x,
                            ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  sg_flexContainerResource (const ::onem2m::flexContainerResource& x, 
                            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                            ::xml_schema::flags f = 0);

  //@}

  /**
   * @name Serialization functions for the %listOfURIs document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  listOfURIs_ (::std::ostream& os,
               const ::onem2m::listOfURIs& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  listOfURIs_ (::std::ostream& os,
               const ::onem2m::listOfURIs& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  listOfURIs_ (::std::ostream& os,
               const ::onem2m::listOfURIs& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  listOfURIs_ (::xercesc::XMLFormatTarget& ft,
               const ::onem2m::listOfURIs& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  listOfURIs_ (::xercesc::XMLFormatTarget& ft,
               const ::onem2m::listOfURIs& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  listOfURIs_ (::xercesc::XMLFormatTarget& ft,
               const ::onem2m::listOfURIs& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  listOfURIs_ (::xercesc::DOMDocument& d,
               const ::onem2m::listOfURIs& x,
               ::xml_schema::flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  listOfURIs_ (const ::onem2m::listOfURIs& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const absRelTimestamp_member&);

  void
  operator<< (::xercesc::DOMAttr&, const absRelTimestamp_member&);

  void
  operator<< (::xml_schema::list_stream&,
              const absRelTimestamp_member&);

  void
  operator<< (::xercesc::DOMElement&, const absRelTimestamp_member1&);

  void
  operator<< (::xercesc::DOMAttr&, const absRelTimestamp_member1&);

  void
  operator<< (::xml_schema::list_stream&,
              const absRelTimestamp_member1&);

  void
  operator<< (::xercesc::DOMElement&, const accessControlContexts&);

  void
  operator<< (::xercesc::DOMElement&, const notificationURI_base&);

  void
  operator<< (::xercesc::DOMAttr&, const notificationURI_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const notificationURI_base&);

  void
  operator<< (::xercesc::DOMElement&, const notificationURI&);

  void
  operator<< (::xercesc::DOMAttr&, const notificationURI&);

  void
  operator<< (::xml_schema::list_stream&,
              const notificationURI&);

  void
  operator<< (::xercesc::DOMElement&, const URIReference&);

  void
  operator<< (::xercesc::DOMElement&, const countryCode1_base&);

  void
  operator<< (::xercesc::DOMAttr&, const countryCode1_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const countryCode1_base&);

  void
  operator<< (::xercesc::DOMElement&, const countryCode1&);

  void
  operator<< (::xercesc::DOMAttr&, const countryCode1&);

  void
  operator<< (::xml_schema::list_stream&,
              const countryCode1&);

  void
  operator<< (::xercesc::DOMElement&, const circRegion_base&);

  void
  operator<< (::xercesc::DOMAttr&, const circRegion_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const circRegion_base&);

  void
  operator<< (::xercesc::DOMElement&, const circRegion&);

  void
  operator<< (::xercesc::DOMAttr&, const circRegion&);

  void
  operator<< (::xml_schema::list_stream&,
              const circRegion&);

  void
  operator<< (::xercesc::DOMElement&, const announcedAttribute_base&);

  void
  operator<< (::xercesc::DOMAttr&, const announcedAttribute_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const announcedAttribute_base&);

  void
  operator<< (::xercesc::DOMElement&, const announcedAttribute&);

  void
  operator<< (::xercesc::DOMAttr&, const announcedAttribute&);

  void
  operator<< (::xml_schema::list_stream&,
              const announcedAttribute&);

  void
  operator<< (::xercesc::DOMElement&, const announcedAttribute1_base&);

  void
  operator<< (::xercesc::DOMAttr&, const announcedAttribute1_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const announcedAttribute1_base&);

  void
  operator<< (::xercesc::DOMElement&, const announcedAttribute1&);

  void
  operator<< (::xercesc::DOMAttr&, const announcedAttribute1&);

  void
  operator<< (::xml_schema::list_stream&,
              const announcedAttribute1&);

  void
  operator<< (::xercesc::DOMElement&, const accessControlIpAddresses&);

  void
  operator<< (::xercesc::DOMElement&, const ipv4Addresses_base&);

  void
  operator<< (::xercesc::DOMAttr&, const ipv4Addresses_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const ipv4Addresses_base&);

  void
  operator<< (::xercesc::DOMElement&, const ipv4Addresses&);

  void
  operator<< (::xercesc::DOMAttr&, const ipv4Addresses&);

  void
  operator<< (::xml_schema::list_stream&,
              const ipv4Addresses&);

  void
  operator<< (::xercesc::DOMElement&, const ipv6Addresses_base&);

  void
  operator<< (::xercesc::DOMAttr&, const ipv6Addresses_base&);

  void
  operator<< (::xml_schema::list_stream&,
              const ipv6Addresses_base&);

  void
  operator<< (::xercesc::DOMElement&, const ipv6Addresses&);

  void
  operator<< (::xercesc::DOMAttr&, const ipv6Addresses&);

  void
  operator<< (::xml_schema::list_stream&,
              const ipv6Addresses&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // XSD_V3_2_0_ED_CDT_COMMON_TYPES_HXX
